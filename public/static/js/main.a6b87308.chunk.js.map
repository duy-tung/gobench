{"version":3,"sources":["context.js","api/api.js","api/gobench.js","views/App/App.js","config/config.js","index.js","realtimeHelpers.js"],"names":["AppContext","createContext","axiosInstance","API","init","baseURL","on401","on404","onNoResponse","axios","create","timeout","headers","Accept","this","interceptors","response","use","undefined","error","status","request","Promise","reject","GoBenchAPI","getAppInfo","resolve","get","then","res","catch","getGroups","getGraphs","id","getMetrics","getMetricData","type","fromTime","toTime","from","end","METRIC_TYPE","COUNTER","HISTOGRAM","GAUGE","GroupComponent","lazy","statusColor","running","finished","cancel","App","useState","groups","fetchGroups","appData","fetchAppData","fetching","setFetching","useEffect","appStatus","className","style","color","background","Provider","value","isArray","length","map","group","index","key","fallback","console","log","process","config","env","apiEndpoint","ReactDOM","render","StrictMode","document","getElementById","values","counter","gauge","INTERVAL","TIME_RANGE","useInterval","callback","delay","savedCallback","useRef","current","setInterval","clearInterval","getValue","metric","valueType","toFixed","getChartData","data","m","x","time","y","Date","getTime","makeHistogramSeriesData","hData","min","max","p75","p95","p99","forEach","d","name","metrics","a","timeRange","timestamp","isRealtime","now","Math","round","metricsData","rs","mData","lastTimestamp","chartData","title","maxBy","all","err","getDataByType","getMetricDataInterval","oldData","mtr","oldMetricData","find","o","dataByType","oldMetricChartData","newData","orderBy","fixSecond","makeChartDataByTimeRange","rawData","timeRangeMiliseconds","seri","seriData","seriDataLength","firstData","lastData","lastDataTime","firstDataTime","dataTime","extraTime","filter"],"mappings":"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","file":"static/js/main.a6b87308.chunk.js","sourcesContent":["import { createContext } from 'react';\n\nexport const AppContext = createContext({});","import axios from 'axios';\nimport { get } from 'lodash';\n\nlet axiosInstance = {};\n\nconst API = {\n  init({\n         baseURL, on401, on404, onNoResponse\n       }) {\n    axiosInstance = axios.create({\n      baseURL,\n      timeout: 10000,\n      headers: {\n        'Content-Type': 'application/json',\n        Accept: 'application/json'\n      }\n    });\n\n    this.on401 = on401 || function noop() {\n    };\n    this.on404 = on404 || function noop() {\n    };\n    this.onNoResponse = onNoResponse || function noop() {\n    };\n    axiosInstance.interceptors.response.use(undefined, (error) => {\n      if (!error.response) {\n        return this.onNoResponse(error);\n      }\n      if (error.response.status === 401) {\n        this.on401(error.request, error.response);\n      }\n      if (error.response.status === 404) {\n        this.on404(error.request, error.response);\n      }\n      return Promise.reject(error);\n    });\n  },\n  axios() {\n    return axiosInstance;\n  }\n};\n\nexport const APIError = err => get(err, ['response', 'data', 'error'], {});\n\nexport default API;\n","import API from './api';\nimport { get } from 'lodash';\nimport { METRIC_TYPE } from '../realtimeHelpers';\n\nconst GoBenchAPI = {\n  getAppInfo() {\n    return new Promise((resolve, reject) => {\n      API.axios().get(`api/application`)\n        .then(res => resolve(get(res, 'data', null)))\n        .catch(reject);\n    });\n  },\n  getGroups() {\n    return new Promise((resolve, reject) => {\n      API.axios().get(`api/groups`)\n        .then(res => resolve(get(res, 'data', [])))\n        .catch(reject);\n    });\n  },\n  getGraphs(id) {\n    return new Promise((resolve, reject) => {\n      API.axios().get(`api/groups/${id}/graphs`)\n        .then(res => resolve(get(res, 'data', [])))\n        .catch(reject);\n    });\n  },\n  getMetrics(id) {\n    return new Promise((resolve, reject) => {\n      API.axios().get(`api/graphs/${id}/metrics`)\n        .then(res => resolve(get(res, 'data', [])))\n        .catch(reject);\n    });\n  },\n  getMetricData(id = 0, type = 'counter', fromTime = null, toTime = null) {\n    const from = fromTime ? `?from=${fromTime}` : '';\n    const end = toTime ? `&end=${toTime}` : '';\n    switch (type) {\n      case METRIC_TYPE.COUNTER:\n        return new Promise((resolve, reject) => {\n          API.axios().get(`api/metrics/${id}/counters${from}${end}`)\n            .then(res => resolve(get(res, 'data', [])))\n            .catch(reject);\n        });\n\n      case METRIC_TYPE.HISTOGRAM:\n        return new Promise((resolve, reject) => {\n          API.axios().get(`api/metrics/${id}/histograms${from}${end}`)\n            .then(res => resolve(get(res, 'data', [])))\n            .catch(reject);\n        });\n\n      case METRIC_TYPE.GAUGE:\n        return new Promise((resolve, reject) => {\n          API.axios().get(`api/metrics/${id}/gauges${from}${end}`)\n            .then(res => resolve(get(res, 'data', [])))\n            .catch(reject);\n        });\n      default:\n        return new Promise((resolve, reject) => {\n          API.axios().get(`api/metrics/${id}`)\n            .then(res => resolve(get(res, 'data', [])))\n            .catch(reject);\n        });\n    }\n  }\n};\n\nexport default GoBenchAPI;\n","import React, { useEffect, useState, lazy, Suspense, createContext } from 'react';\nimport { isArray, get } from 'lodash';\nimport './App.css';\nimport GoBenchAPI from '../../api/gobench';\nimport { AppContext } from '../../context';\nimport { useInterval } from '../../realtimeHelpers';\n\nconst GroupComponent = lazy(() => import('./Group'));\n\nconst loading = () => <p>Loading group...</p>;\n\nconst statusColor = {\n  running: '#4dbd74',\n  init: '#ffcc00',\n  finished: '#0066ff',\n  cancel: '#ff0000'\n};\n\nfunction App() {\n  const [groups, fetchGroups] = useState([]);\n  const [appData, fetchAppData] = useState(null);\n  const [fetching, setFetching] = useState(false);\n\n  useEffect(() => {\n    setFetching(true);\n    GoBenchAPI.getAppInfo().then(res => {\n      setFetching(false);\n      fetchAppData(res);\n    })\n  }, []);\n  useEffect(() => {\n    if (appData) {\n      GoBenchAPI.getGroups().then(res => {\n        fetchGroups(res);\n      })\n    }\n  }, [appData]);\n  const appStatus = get(appData, 'status', '');\n  if (!appData && !fetching) {\n    return <div className=\"app\">\n      <p>Cannot load the application. May be your benchmark has been stopped.</p>\n    </div>\n  }\n\n  return !fetching && (\n    <div className=\"app\">\n      <div className=\"app-header\">\n        <h2>{get(appData, 'name', '') || ''}</h2>\n        <span\n          style={{\n            color: '#FFFFFF',\n            background: statusColor[appStatus] || '#bfbfbf',\n          }}>{get(appData, 'status', '')}</span>\n      </div>\n      <div className=\"container\">\n        <AppContext.Provider value={appData}>\n          {\n            (isArray(groups) && groups.length > 0) &&\n            groups.map((group, index) => {\n              return <Suspense key={group.id || index} fallback={loading()}>\n                <GroupComponent group={group} appData={appData}/>\n              </Suspense>\n            })\n          }\n        </AppContext.Provider>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import * as configDefault from './config.default';\n\nconsole.log('process.env.NODE_ENV :', process.env.NODE_ENV);\nconst config = {\n  env: process.env.NODE_ENV,\n  apiEndpoint: process.env.NODE_ENV === \"production\" ? '/' : configDefault.apiEndpoint,\n};\nexport default config;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './views/App/App';\nimport API from './api/api';\nimport config from './config/config';\n// import * as serviceWorker from './serviceWorker';\n\nAPI.init({\n  baseURL: config.apiEndpoint,\n  on404: () => {\n    console.log('API not found');\n  }\n});\n\nReactDOM.render(\n  <React.StrictMode>\n    <App/>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\n// serviceWorker.unregister();\n","import { useEffect, useRef } from 'react';\nimport { get, isArray, maxBy, orderBy } from 'lodash';\nimport GoBenchAPI from './api/gobench';\n\nconst values = {\n  counter: 'count',\n  gauge: 'value'\n};\nexport const METRIC_TYPE = {\n  HISTOGRAM: 'histogram',\n  COUNTER: 'counter',\n  GAUGE: 'gauge'\n};\n\nexport const INTERVAL = 10000; // realtime data inteval in miliseconds\nexport const DEFAULT_VALUE = null; // default value for empty data \n\nexport const TIME_RANGE = {\n  '5m': 5 * 60,\n  '15m': 15 * 60,\n  '30m': 30 * 60,\n  '1h': 60 * 60,\n  '12h': 12 * 60 * 60,\n  '24h': 24 * 60 * 60\n};\n\n/***\n * useInterval\n * hook API written by Dan Abramov\n * @param callback\n * @param delay\n */\nexport const useInterval = (callback, delay) => {\n  const savedCallback = useRef();\n  useEffect(() => {\n    savedCallback.current = callback;\n  }, [callback]);\n\n  useEffect(() => {\n    function tick() {\n      savedCallback.current();\n    }\n\n    if (delay !== null) {\n      let id = setInterval(tick, delay);\n      return () => clearInterval(id);\n    }\n  }, [delay]);\n};\n\n/***\n * get value of metric by type\n * @param metric\n * @param valueType\n * @returns {*|number}\n */\nconst getValue = (metric, valueType) => (metric[valueType]).toFixed(0) || DEFAULT_VALUE;\n\n/***\n * Get chart data depend on metric type\n * @param type\n * @param data\n * @returns {*}\n */\nconst getChartData = (type, data) => isArray(data) ? data.map(m => ({\n  x: m.time,\n  y: getValue(m, values[type])\n})) : [{\n  x: new Date(data.time).getTime(),\n  y: getValue(data, values[type])\n}];\n\n\n/***\n * Make chartData by metric type\n * @param data\n * @returns {({data: ([]|*[]), name: string}|{data: ([]|*[]), name: string}|{data: ([]|*[]), name: string}|{data: ([]|*[]), name: string}|{data: ([]|*[]), name: string})[]|{data: *, name: *}}\n */\nexport const makeHistogramSeriesData = (data) => {\n  let hData = { min: [], max: [], p75: [], p95: [], p99: [] };\n  data.forEach(d => {\n    hData = {\n      min: [...hData.min, { x: d.time, y: (d.min).toFixed(0) || 0 }],\n      max: [...hData.max, { x: d.time, y: (d.max).toFixed(0) || 0 }],\n      p75: [...hData.p75, { x: d.time, y: (d.p75).toFixed(0) || 0 }],\n      p95: [...hData.p95, { x: d.time, y: (d.p95).toFixed(0) || 0 }],\n      p99: [...hData.p99, { x: d.time, y: (d.p99).toFixed(0) || 0 }],\n    }\n  });\n\n  return [\n    { name: 'min', data: hData.min },\n    { name: 'max', data: hData.max },\n    { name: 'p75', data: hData.p75 },\n    { name: 'p95', data: hData.p95 },\n    { name: 'p99', data: hData.p99 }\n  ]\n};\n\n/***\n * get metrics data (first fetch)\n * @param metrics\n * @param timeRange\n * @param timestamp\n * @param isRealtime\n * @returns {Promise<unknown[]>}\n */\nexport const getMetricData = async (metrics, timeRange = 3600, timestamp, isRealtime) => {\n  const now = new Date().getTime();\n  const fromTime = Math.round((now - timestamp) / 1000) < timeRange ? timestamp : (now - (timeRange * 1000));\n  const metricsData = metrics.map(async m => {\n    let mData;\n    if (isRealtime) {\n      mData = await GoBenchAPI.getMetricData(m.id, m.type, fromTime, now).then(rs => rs);\n    } else {\n      mData = await GoBenchAPI.getMetricData(m.id, m.type).then(rs => rs);\n    }\n    if (mData.length === 0) {\n      return {\n        ...m,\n        lastTimestamp: timestamp,\n        chartData: {\n          name: m.title,\n          data: []\n        }\n      };\n    }\n    const lastTimestamp = get(maxBy(mData, m => m.time), 'time');\n    return {\n      ...m,\n      lastTimestamp,\n      chartData: {\n        name: m.title,\n        data: m.type === METRIC_TYPE.HISTOGRAM ? mData : getChartData(m.type, mData)\n      }\n    }\n  });\n  return await Promise.all(metricsData)\n    .then(rs => rs)\n    .catch(err => err);\n};\n\nconst getDataByType = (data, type) => {\n  return (type === METRIC_TYPE.HISTOGRAM ? data : getChartData(type, data));\n};\n\n/***\n * get metrics data interval\n * @param metrics\n * @param oldData\n * @returns {Promise<unknown[]>}\n */\nexport const getMetricDataInterval = async (metrics, oldData = null) => {\n  return await Promise.all(metrics.map(mtr => {\n    const oldMetricData = oldData.find(o => mtr.id === get(o, ['id'], ''));\n    const timestamp = get(oldMetricData, 'lastTimestamp', '');\n    if (timestamp) {\n      return GoBenchAPI.getMetricData(mtr.id, mtr.type, timestamp)\n        .then(mData => {\n          if (mData.length > 0) {\n            const dataByType = getDataByType(mData, mtr.type);\n            const oldMetricChartData = get(oldMetricData, ['chartData', 'data'], []);\n            const newData = [...oldMetricChartData, ...dataByType];\n            return {\n              ...oldMetricData,\n              lastTimestamp: get(orderBy(mData, ['time'], 'desc'), '[0].time'),\n              chartData: {\n                name: mtr.title,\n                data: newData\n              }\n            }\n          }\n          return oldMetricData;\n        });\n    }\n    return oldMetricData;\n  }))\n    .then(rs => rs)\n    .catch(err => err);\n};\n\n/**\n * make timestamp without to second\n * @param timestamp\n * @returns {number}\n */\nconst fixSecond = (timestamp) => Math.round(timestamp / 1000) * 1000;\n\n/***\n * Make chart data by time range\n * @param rawData\n * @param timeRange\n * @returns {*}\n */\nexport const makeChartDataByTimeRange = (rawData = [], timeRange = 3600) => {\n  const timeRangeMiliseconds = timeRange * 1000;\n  return rawData.map((seri) => {\n    const seriData = get(seri, 'data', []);\n    if (seriData.length === 0) {\n      return [];\n    }\n    const seriDataLength = seriData.length || 0;\n    const firstData = seriData[0];\n    const lastData = seriData[seriDataLength - 1];\n    const lastDataTime = get(lastData, 'x', 0);\n    const firstDataTime = get(firstData, 'x', 0);\n    const dataTime = fixSecond(lastDataTime - firstDataTime);\n\n    if (dataTime < timeRangeMiliseconds) {\n      const extraTime = timeRangeMiliseconds - dataTime;\n      return {\n        ...seri,\n        data: [...seriData, { x: lastDataTime + extraTime, y: DEFAULT_VALUE }]\n      }\n    }\n    return {\n      ...seri,\n      data: seriData.filter(d => d.x >= (fixSecond(lastDataTime) - timeRangeMiliseconds))\n    }\n  });\n}; "],"sourceRoot":""}